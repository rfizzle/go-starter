// Code generated by go-swagger; DO NOT EDIT.

package auth

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the auth client
type API interface {
	/*
	   AuthCheckV1 checks if the user is authenticated

	   Check if the user is authenticated
	*/
	AuthCheckV1(ctx context.Context, params *AuthCheckV1Params) (*AuthCheckV1OK, error)
	/*
	   AuthLoginV1 logins a user

	   Authenticates a user from a username and password and returns a JWT in the response and inside a
	   signed cookie.
	*/
	AuthLoginV1(ctx context.Context, params *AuthLoginV1Params) (*AuthLoginV1OK, error)
	/*
	   AuthLogoutV1 logouts the current user

	   Invalidates an authenticated user's session and cookie
	*/
	AuthLogoutV1(ctx context.Context, params *AuthLogoutV1Params) (*AuthLogoutV1OK, error)
}

// New creates a new auth API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for auth API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
AuthCheckV1 checks if the user is authenticated

Check if the user is authenticated
*/
func (a *Client) AuthCheckV1(ctx context.Context, params *AuthCheckV1Params) (*AuthCheckV1OK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthCheckV1",
		Method:             "GET",
		PathPattern:        "/v1/auth/check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthCheckV1Reader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthCheckV1OK:
		return value, nil
	case *AuthCheckV1Unauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthCheckV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AuthLoginV1 logins a user

Authenticates a user from a username and password and returns a JWT in the response and inside a
signed cookie.
*/
func (a *Client) AuthLoginV1(ctx context.Context, params *AuthLoginV1Params) (*AuthLoginV1OK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthLoginV1",
		Method:             "POST",
		PathPattern:        "/v1/auth/login",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthLoginV1Reader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthLoginV1OK:
		return value, nil
	case *AuthLoginV1BadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *AuthLoginV1InternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthLoginV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AuthLogoutV1 logouts the current user

Invalidates an authenticated user's session and cookie
*/
func (a *Client) AuthLogoutV1(ctx context.Context, params *AuthLogoutV1Params) (*AuthLogoutV1OK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthLogoutV1",
		Method:             "POST",
		PathPattern:        "/v1/auth/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthLogoutV1Reader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthLogoutV1OK:
		return value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthLogoutV1: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
