// Code generated by go-swagger; DO NOT EDIT.

package auth

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"fmt"

	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

//go:generate mockery --name API --keeptree --with-expecter --case underscore

// API is the interface of the auth client
type API interface {
	/*
	   AuthCheck checks if the user is authenticated

	   Check if the user is authenticated
	*/
	AuthCheck(ctx context.Context, params *AuthCheckParams) (*AuthCheckOK, error)
	/*
	   AuthLogin logins a user

	   Authenticates a user from a username and password and returns a JWT in the response and inside a
	   signed cookie.
	*/
	AuthLogin(ctx context.Context, params *AuthLoginParams) (*AuthLoginOK, error)
	/*
	   AuthLogout logouts the current user

	   Invalidates an authenticated user's session and cookie
	*/
	AuthLogout(ctx context.Context, params *AuthLogoutParams) (*AuthLogoutOK, error)
}

// New creates a new auth API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry, authInfo runtime.ClientAuthInfoWriter) *Client {
	return &Client{
		transport: transport,
		formats:   formats,
		authInfo:  authInfo,
	}
}

/*
Client for auth API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
	authInfo  runtime.ClientAuthInfoWriter
}

/*
AuthCheck checks if the user is authenticated

Check if the user is authenticated
*/
func (a *Client) AuthCheck(ctx context.Context, params *AuthCheckParams) (*AuthCheckOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthCheck",
		Method:             "GET",
		PathPattern:        "/api/v1/auth/check",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthCheckReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthCheckOK:
		return value, nil
	case *AuthCheckUnauthorized:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthCheck: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AuthLogin logins a user

Authenticates a user from a username and password and returns a JWT in the response and inside a
signed cookie.
*/
func (a *Client) AuthLogin(ctx context.Context, params *AuthLoginParams) (*AuthLoginOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthLogin",
		Method:             "POST",
		PathPattern:        "/api/v1/auth/login",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthLoginReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthLoginOK:
		return value, nil
	case *AuthLoginBadRequest:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	case *AuthLoginInternalServerError:
		return nil, runtime.NewAPIError("unsuccessful response", value, value.Code())
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthLogin: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
AuthLogout logouts the current user

Invalidates an authenticated user's session and cookie
*/
func (a *Client) AuthLogout(ctx context.Context, params *AuthLogoutParams) (*AuthLogoutOK, error) {

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "AuthLogout",
		Method:             "POST",
		PathPattern:        "/api/v1/auth/logout",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthLogoutReader{formats: a.formats},
		AuthInfo:           a.authInfo,
		Context:            ctx,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	switch value := result.(type) {
	case *AuthLogoutOK:
		return value, nil
	}
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for AuthLogout: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}
